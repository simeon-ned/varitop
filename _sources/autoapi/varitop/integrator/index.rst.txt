varitop.integrator
==================

.. py:module:: varitop.integrator

.. autoapi-nested-parse::

   Integrators



Classes
-------

.. autoapisummary::

   varitop.integrator.VariationalIntegrator
   varitop.integrator.DelIntegrator
   varitop.integrator.DelmIntegrator


Functions
---------

.. autoapisummary::

   varitop.integrator.quat_prod
   varitop.integrator.qconj
   varitop.integrator.euler_rule


Module Contents
---------------

.. py:function:: quat_prod(q1: casadi.SX, q2: casadi.SX) -> casadi.SX

   Quaternion product

   :param q1: first quaternion
   :param q2: second quaternion
   :type q1: casadi.SX
   :type q2: casadi.SX
   :return: q1 * q2
   :rtype: casadi.SX


.. py:function:: qconj(q: casadi.SX) -> casadi.SX

   Quaternion conjugate

   :param q: quaternion to conjugate
   :type q: casadi.SX
   :return: q*
   :rtype: casadi.SX


.. py:function:: euler_rule(q1: casadi.SX, q2: casadi.SX, dt: casadi.SX) -> [casadi.SX, casadi.SX]

   Euler midpoint rule for integration

   :param q1: first state
   :param q2: second state
   :param dt: time step
   :type q1: casadi.SX
   :type q2: casadi.SX
   :type dt: casadi.SX
   :return: q, dq
   :rtype: Tuple[casadi.SX, casadi.SX]


.. py:class:: VariationalIntegrator(nq: int = None, nu: int = None, free_body: bool = False, lagrangian: casadi.Function = None, rule: casadi.Function = euler_rule, selector: casadi.SX = None)

   Abstract variational integrator class


   .. py:method:: create_variables()


   .. py:method:: add_force(expr: casadi.SX)


   .. py:method:: add_constraint(expr: casadi.SX)


   .. py:property:: selector
      :type: casadi.SX

      Selector matrix



   .. py:property:: free_body
      :type: bool

      Index of quaternion in generalized coordinates



   .. py:method:: v(q: casadi.SX, dq: casadi.SX) -> casadi.SX


   .. py:method:: q2w(quat: casadi.SX, quat_dot: casadi.SX) -> casadi.SX

      Angular velocity from quaternion and its derivative

      :math:`\omega = 2 L(\bar{q}) \dot{q}`

      :param quat: quaternion
      :type quat: casadi.SX
      :param quat_dot: quaternion derivative
      :type quat_dot: casadi.SX
      :return: angular velocity 4x1
      :rtype: casadi.SX



   .. py:property:: lagrangian
      :type: casadi.Function

      System's continuous lagrangian



   .. py:property:: rule
      :type: casadi.Function

      Midpoint rule



   .. py:property:: nq
      :type: int

      Number of generalized coordinates



   .. py:property:: nu
      :type: int

      Number of controls



   .. py:method:: _discrete_lagrangian() -> casadi.Function

      Discretization of system's lagrangian

      :return: Ld(q0, q1, h)
      :rtype: casadi.Function



   .. py:method:: get_residual()
      :abstractmethod:


      Formulate the residual



   .. py:method:: get_rf_residual()
      :abstractmethod:


      Reformulate the residual
      to casadi.rootfinder problem



   .. py:method:: step()
      :abstractmethod:


      Perform a step of integration



   .. py:method:: _append_generalized_force(force: casadi.Function)

      Compose a force, acting on a body

      :param force: force to add (required to be in the state-space)
      :type force: casadi.Function



   .. py:method:: add_generalized_forces(forces: List[casadi.Function])

      Wrapper for forces lists

      :param forces: A list of forces
      :type forces: List[casadi.Function]



   .. py:method:: _append_dynamics_constraint(constr: casadi.Function)

      Add phi(q) for constrained dynamics

      :param constr: constraint residual
      :type constr: casadi.Function



   .. py:method:: add_dynamics_constraints(constraints: List[casadi.Function])

      Wrapper for constraints lists

      :param constraints: A list of constraints
      :type constraints: List[casadi.Function]



.. py:class:: DelIntegrator(nq: int = None, nu: int = None, free_body: bool = False, lagrangian: casadi.Function = None, rule: casadi.Function = euler_rule, selector: casadi.SX = None)

   Bases: :py:obj:`VariationalIntegrator`


   Discrete Euler-Lagrange integrator


   .. py:method:: get_residual() -> casadi.Function

      Formulate Discrete Euler-Lagrange residual



   .. py:method:: get_rf_residual() -> casadi.Function

      Reformulate residual to match rootfinder signature



   .. py:method:: step(q0: numpy.ndarray, q1: numpy.ndarray, dt: float, u: numpy.ndarray = None) -> numpy.ndarray

      :param q0: :math:`q_{k-1}`
      :type q0: np.ndarray
      :param q1: :math:`q_{k}`
      :type q1: np.ndarray
      :param dt: :math:`\mathrm{d}t`
      :type dt: float
      :param u: :math:`u_{k}`
      :type u: np.ndarray
      :return: :math:`q_{k+1}`
      :rtype: np.ndarray


      DEL Residual evolution described by: :math:`(q_0, q_1) \rightarrow (q_1, q_2)`



.. py:class:: DelmIntegrator(nq: int = None, nu: int = None, free_body: bool = False, lagrangian: casadi.Function = None, rule: casadi.Function = euler_rule, selector: casadi.SX = None)

   Bases: :py:obj:`VariationalIntegrator`


   Discrete Euler-Lagrange in Momentum form


   .. py:method:: step()
      :abstractmethod:


      (q0, p0) -> (q1, p1)



